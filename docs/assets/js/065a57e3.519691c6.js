(self.webpackChunkwoshicai=self.webpackChunkwoshicai||[]).push([[794],{1323:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return l},metadata:function(){return i},toc:function(){return c},default:function(){return u}});var a=t(2122),r=t(9756),o=(t(7294),t(3905)),l={slug:"Concurrency In Go",title:"Concurrency In Go",author:"woshicai",author_title:"woshicai",author_image_url:"https://avatars.githubusercontent.com/charles-woshicai",tags:["go"]},i={permalink:"/blog/Concurrency In Go",editUrl:"https://github.com/charles-woshicai/charles-woshicai.github.io/edit/master/docs/blog/blog/concurrency-in-go.md",source:"@site/blog/concurrency-in-go.md",title:"Concurrency In Go",description:"After reading the book Concurrency In Go, in order to better understand and remember what the book says, record key point about the book.",date:"2021-05-05T16:16:32.369Z",formattedDate:"May 6, 2021",tags:[{label:"go",permalink:"/blog/tags/go"}],readingTime:12.545,truncated:!1,nextItem:{title:"Welcome",permalink:"/blog/welcome"}},c=[{value:"Charter 1. An introduction to Concurrency",id:"charter-1-an-introduction-to-concurrency",children:[{value:"Moore&#39;s Law, Web Scale, and the Mess We&#39;re In",id:"moores-law-web-scale-and-the-mess-were-in",children:[]},{value:"Why is Concurrency Hard",id:"why-is-concurrency-hard",children:[]}]},{value:"Charter 2. Modeling Your Code: Communicating Sequential Processes",id:"charter-2-modeling-your-code-communicating-sequential-processes",children:[{value:"The Difference Between Concurrency and Parallelism",id:"the-difference-between-concurrency-and-parallelism",children:[]},{value:"What Is CSP?",id:"what-is-csp",children:[]}]},{value:"Chapter 3. Go\u2019s Concurrency Building Blocks",id:"chapter-3-gos-concurrency-building-blocks",children:[{value:"goroutine",id:"goroutine",children:[]},{value:"The sync Package",id:"the-sync-package",children:[]},{value:"Channels",id:"channels",children:[]},{value:"The select Statement",id:"the-select-statement",children:[]},{value:"The GOMAXPROCS Lever",id:"the-gomaxprocs-lever",children:[]}]},{value:"Chapter 4. Concurrency Patterns in Go",id:"chapter-4-concurrency-patterns-in-go",children:[{value:"Confinement",id:"confinement",children:[]},{value:"The for-select Loop",id:"the-for-select-loop",children:[]},{value:"Preventing Goroutine Leaks",id:"preventing-goroutine-leaks",children:[]},{value:"The or-channel",id:"the-or-channel",children:[]},{value:"Pipelines",id:"pipelines",children:[]},{value:"Fan-Out, Fan-In",id:"fan-out-fan-in",children:[]},{value:"The or-done-channel",id:"the-or-done-channel",children:[]},{value:"The tee-channel",id:"the-tee-channel",children:[]},{value:"The bridge-channel",id:"the-bridge-channel",children:[]},{value:"queuing",id:"queuing",children:[]},{value:"The context Package",id:"the-context-package",children:[]}]},{value:"Chapter 5. Concurrency at Scale",id:"chapter-5-concurrency-at-scale",children:[{value:"Error Propagation",id:"error-propagation",children:[]},{value:"Timeouts and Cancellation",id:"timeouts-and-cancellation",children:[]},{value:"Heartbeats",id:"heartbeats",children:[]},{value:"Replicated Requests",id:"replicated-requests",children:[]},{value:"Rate Limiting",id:"rate-limiting",children:[]},{value:"Healing Unhealthy Goroutines",id:"healing-unhealthy-goroutines",children:[]}]},{value:"Chapter 6. Goroutines and the Go Runtime",id:"chapter-6-goroutines-and-the-go-runtime",children:[{value:"work steal",id:"work-steal",children:[]}]}],s={toc:c};function u(e){var n=e.components,t=(0,r.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,a.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"After reading the book ",(0,o.kt)("inlineCode",{parentName:"p"},"Concurrency In Go"),", in order to better understand and remember what the book says, record key point about the book."),(0,o.kt)("h2",{id:"charter-1-an-introduction-to-concurrency"},"Charter 1. An introduction to Concurrency"),(0,o.kt)("p",null,"\u7b2c\u4e00\u8282\u4e3b\u8981\u4ecb\u7ecd\u4e86Concurrency\u7684\u5b9a\u4e49\u4ee5\u53ca\u5386\u53f2"),(0,o.kt)("h3",{id:"moores-law-web-scale-and-the-mess-were-in"},"Moore's Law, Web Scale, and the Mess We're In"),(0,o.kt)("p",null,"\u4ecb\u7ecd\u4e86\u6469\u5c14\u5b9a\u5f8b\u4ee5\u53caAmdahl\u2019s Law\n",(0,o.kt)("a",{parentName:"p",href:"https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B"},"\u6469\u5c14\u5b9a\u5f8b"),"\n",(0,o.kt)("a",{parentName:"p",href:"https://zh.wikipedia.org/wiki/%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B"},"Amdahl\u2019s Law")),(0,o.kt)("h3",{id:"why-is-concurrency-hard"},"Why is Concurrency Hard"),(0,o.kt)("p",null,"\u4ecb\u7ecd\u51e0\u79cd\u5f15\u5165concurrency\u5e26\u6765\u7684\u901a\u7528\u95ee\u9898"),(0,o.kt)("h4",{id:"race-condition"},"Race Condition"),(0,o.kt)("p",null,"\u201cA race condition occurs when two or more operations must execute in the correct order, but the program has not been written so that this order is guaranteed to be maintained\u201d"),(0,o.kt)("p",null,"\u7b80\u5355\u6765\u8bf4\u5c31\u662f\u4e00\u81f4\u6027\u95ee\u9898"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"\u4e00\u4e2a\u7b80\u5355\u7684\u53cd\u9762\u4f8b\u5b50"),(0,o.kt)("pre",{parentName:"blockquote"},(0,o.kt)("code",{parentName:"pre",className:"language-go"},'1 var data int\n2 go func() { \n3     data++\n4 }()\n5 if data == 0 {\n6     fmt.Printf("the value is %v.\\n", data)\n7 }\n'))),(0,o.kt)("h4",{id:"atomicity"},"Atomicity"),(0,o.kt)("p",null,"\u201cWhen something is considered atomic, or to have the property of atomicity, this means that within the context that it is operating, it is indivisible, or uninterruptible.\u201d"),(0,o.kt)("p",null,"\u539f\u5b50\u6027 \u4e0d\u53ef\u6253\u65ad\u7684\u6700\u5c0f\u64cd\u4f5c"),(0,o.kt)("h4",{id:"memory-access-synchronization"},"Memory Access Synchronization"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://golang.org/ref/mem"},"\u5b98\u65b9\u53c2\u8003\u8d44\u6599")),(0,o.kt)("h4",{id:"deadlocks-livelocks-and-starvation"},"Deadlocks, Livelocks, and Starvation"),(0,o.kt)("h5",{id:"deadlock"},"Deadlock"),(0,o.kt)("p",null,"\u6b7b\u9501"),(0,o.kt)("p",null,"\u5e38\u89c1\u7684\u51e0\u79cd\u573a\u666f"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Mutual Exclusion",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"A concurrent process holds exclusive rights to a resource at any one time"))),(0,o.kt)("li",{parentName:"ul"},"Wait for condition",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"A concurrent process must simultaneously hold a resource and be waiting for an additional resource."))),(0,o.kt)("li",{parentName:"ul"},"No Preemption",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"A resource held by a concurrent process can only be released by that process, so it fulfills this condition."))),(0,o.kt)("li",{parentName:"ul"},"Circular Wait",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"A concurrent process (P1) must be waiting on a chain of other concurrent processes (P2), which are in turn waiting on it (P1), so it fulfills this final condition too.")))),(0,o.kt)("h5",{id:"livelock"},"Livelock"),(0,o.kt)("p",null,"Livelocks are programs that are actively performing concurrent operations, but these operations do nothing to move the state of the program forward."),(0,o.kt)("p",null,"\u7a0b\u5e8f\u5728\u8dd1 \u4f46\u662f\u7a0b\u5e8f\u7684\u72b6\u6001\u4e00\u76f4\u505c\u7559\u5728\u539f\u5730"),(0,o.kt)("h5",{id:"starvation"},"Starvation"),(0,o.kt)("p",null,"Starvation is any situation where a concurrent process cannot get all the resources it needs to perform work."),(0,o.kt)("p",null,"\u8fc7\u591a\u7684\u7a0b\u5e8f\u5728\u7ade\u4e89\u8d44\u6e90 \u5bfc\u81f4\u8d44\u6e90\u90fd\u8017\u8d39\u5728\u8c03\u5ea6\u4e0a\u4e86 \u7ed3\u679c\u5927\u5bb6\u90fd\u5206\u4e0d\u5230\u8d44\u6e90"),(0,o.kt)("h5",{id:"determining-concurrency-safety"},"Determining Concurrency Safety"),(0,o.kt)("h4",{id:"simplicity-in-the-face-of-complexity"},"Simplicity in the Face of Complexity"),(0,o.kt)("p",null,"\u4ecb\u7ecd\u4e86\u548c\u5176\u4ed6\u53d8\u6210\u8bed\u8a00\u76f8\u6bd4 go\u5728concurrency\u8fd9\u5757\u505a\u4e86\u54ea\u4e9b\u5de5\u4f5c:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u5185\u5b58\u7ba1\u7406 \u5373 gc"),(0,o.kt)("li",{parentName:"ul"},"goroutine\u8c03\u5ea6 \u62bd\u8c61\u7684goroutine\u8c03\u5ea6\u5230\u64cd\u4f5c\u7cfb\u7edf\u7684thread")),(0,o.kt)("h2",{id:"charter-2-modeling-your-code-communicating-sequential-processes"},"Charter 2. Modeling Your Code: Communicating Sequential Processes"),(0,o.kt)("h3",{id:"the-difference-between-concurrency-and-parallelism"},"The Difference Between Concurrency and Parallelism"),(0,o.kt)("p",null,"The fact that concurrency is different from parallelism is often overlooked or misunderstood. In conversations between many developers, the two terms are often used interchangeably to mean \u201csomething that runs at the same time as something else.\u201d Sometimes using the word \u201cparallel\u201d in this context is correct, but usually if the developers are discussing code, they really ought to be using the word \u201cconcurrent.\n\u5e76\u53d1\u548c\u5e76\u884c\u7684\u533a\u522b"),(0,o.kt)("h3",{id:"what-is-csp"},"What Is CSP?"),(0,o.kt)("p",null,"CSP: Communicating Sequential Processes\n",(0,o.kt)("a",{parentName:"p",href:"https://dl.acm.org/doi/10.1145/359576.359585"},"CSP Paper")),(0,o.kt)("p",null,"\u5e38\u89c4\u7684\u5e76\u53d1\u5b89\u5168\u601d\u8def\u662f\u901a\u8fc7\u5bf9\u5185\u5b58\u7684\u8bbf\u95ee\u987a\u5e8f\u505a\u6587\u7ae0\u6765\u4fdd\u8bc1\u5185\u5b58\u7684\u4e00\u81f4\u6027, CSP\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u7684\u601d\u8def, \u5e76\u53d1\u7a0b\u5e8f\u4e4b\u95f4\u901a\u8fc7\u663e\u5f0f\u7684\u8f93\u5165\u8f93\u51fa\u6765\u63a7\u5236\u6570\u636e\u7684access."),(0,o.kt)("h4",{id:"how-this-helps-you"},"How This Helps You"),(0,o.kt)("p",null,"go\u91c7\u7eb3\u4e86CSP\u7684\u601d\u8def\u6765\u5b9e\u73b0\u5e76\u53d1, \u8bde\u751f\u4e86goroutine\u548cchannel."),(0,o.kt)("h4",{id:"gos-philosophy-on-concurrency"},"Go\u2019s Philosophy on Concurrency"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://golang.org/ref/mem"},"\u5b98\u65b9\u53c2\u8003\u8d44\u6599")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"\u5173\u4e8e\u9009\u62e9channel\u8fd8\u662fsync\u5305\u7684\u53c2\u8003")),(0,o.kt)("hr",null),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"evernotecid://C89FDA3E-A873-421C-BFAE-498A116E39F9/appyinxiangcom/27330777/ENResource/p103",alt:"d04f6a989475155abb25e5407ce337af.png"})),(0,o.kt)("h2",{id:"chapter-3-gos-concurrency-building-blocks"},"Chapter 3. Go\u2019s Concurrency Building Blocks"),(0,o.kt)("p",null,"\u4ecb\u7ecdgo\u5173\u4e8econcurrency\u76f8\u5173\u7684feature\u652f\u6301"),(0,o.kt)("h3",{id:"goroutine"},"goroutine"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"#https://golang.org/doc/faq#goroutines"},"\u5b98\u65b9FAQ")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"goroutine"),"\u662fgo\u5c01\u88c5\u7684\u7ed3\u6784"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"coroutine"),"\u662f\u5728\u64cd\u4f5c\u7cfb\u7edfthread\u6982\u5ff5\u4e4b\u4e0a\u7684\u62bd\u8c61, \u867d\u7136\u770b\u8d77\u6765\u6bd4\u76f4\u63a5\u7528\u7ebf\u7a0b\u9ebb\u70e6, \u4f46\u662f\u5bf9\u4e8econcurrency\u6765\u8bf4\u6709\u5f88\u5927\u597d\u5904 \u56e0\u4e3a\u5bf9\u4e8eio\u573a\u666f\u7ebf\u7a0b\u592a\u91cd\u4e86."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"goroutine"),"\u662f",(0,o.kt)("inlineCode",{parentName:"li"},"fork-join"),"\u7684model",(0,o.kt)("img",{parentName:"li",src:"evernotecid://C89FDA3E-A873-421C-BFAE-498A116E39F9/appyinxiangcom/27330777/ENResource/p104",alt:"86576fcfeefa4238bdc62549c964a98b.png"})),(0,o.kt)("li",{parentName:"ul"},"there is ",(0,o.kt)("inlineCode",{parentName:"li"},"no Guarantee")," the order of goroutine executes."),(0,o.kt)("li",{parentName:"ul"},"support closure")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'var wg sync.WaitGroup\nsalutation := "hello"\nwg.Add(1)\ngo func() {\n    defer wg.Done()\n    salutation = "welcome" \n}()\nwg.Wait()\nfmt.Println(salutation)\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"M:N\u7684\u8c03\u5ea6\u6a21\u578b"),(0,o.kt)("li",{parentName:"ul"},"KB\u7ea7\u522b\u7684\u4e0a\u4e0b\u6587(\u7ebf\u7a0b\u662f2MB)\n",(0,o.kt)("img",{parentName:"li",src:"evernotecid://C89FDA3E-A873-421C-BFAE-498A116E39F9/appyinxiangcom/27330777/ENResource/p105",alt:"0ad10f36d042c9b042cc796b14200d21.png"}))),(0,o.kt)("h3",{id:"the-sync-package"},"The sync Package"),(0,o.kt)("h4",{id:"waitgroup"},"WaitGroup"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'var wg sync.WaitGroup\n\nwg.Add(1)                       \ngo func() {\n    defer wg.Done()             \n    fmt.Println("1st goroutine sleeping...")\n    time.Sleep(1)\n}()\n\nwg.Add(1)                       \ngo func() {\n    defer wg.Done()             \n    fmt.Println("2nd goroutine sleeping...")\n    time.Sleep(2)\n}()\n\nwg.Wait()                       \nfmt.Println("All goroutines complete.")\n')),(0,o.kt)("h4",{id:"mutex-and-rwmutex"},"Mutex and RWMutex"),(0,o.kt)("p",null,"\u9501\u548c\u8bfb\u5199\u9501"),(0,o.kt)("h4",{id:"cond"},"Cond"),(0,o.kt)("p",null,"...a rendezvous point for goroutines waiting for or announcing the occurrence\nof an event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"c := sync.NewCond(&sync.Mutex{}) \nc.L.Lock() \nfor conditionTrue() == false {\n    c.Wait() \n}\nc.L.Unlock()\n")),(0,o.kt)("h4",{id:"once"},"Once"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'var count int\n\nincrement := func() {\n    count++\n}\n\nvar once sync.Once\n\nvar increments sync.WaitGroup\nincrements.Add(100)\nfor i := 0; i < 100; i++ {\n    go func() {\n        defer increments.Done()\n        once.Do(increment)\n    }()\n}\n\nincrements.Wait()\nfmt.Printf("Count is %d\\n", count)\n')),(0,o.kt)("p",null,"\u8f93\u51fa: ",(0,o.kt)("inlineCode",{parentName:"p"},"Count is 1")),(0,o.kt)("h4",{id:"pool"},"Pool"),(0,o.kt)("p",null,"So when working with a Pool, just remember the following points:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"When instantiating sync.Pool, give it a New member variable that is thread-safe when called."),(0,o.kt)("li",{parentName:"ul"},"When you receive an instance from Get, make no assumptions regarding the state of the object you receive back."),(0,o.kt)("li",{parentName:"ul"},"Make sure to call Put when you\u2019re finished with the object you pulled out of the pool. Otherwise, the Pool is useless. Usually this is done with defer."),(0,o.kt)("li",{parentName:"ul"},"Objects in the pool must be roughly uniform in makeup.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'myPool := &sync.Pool{\n    New: func() interface{} {\n        fmt.Println("Creating new instance.")\n        return struct{}{}\n    },\n}\n\nmyPool.Get() \ninstance := myPool.Get() \nmyPool.Put(instance) \nmyPool.Get()\n')),(0,o.kt)("h3",{id:"channels"},"Channels"),(0,o.kt)("p",null,"Channels are one of the synchronization primitives in Go derived from Hoare\u2019s CSP."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"evernotecid://C89FDA3E-A873-421C-BFAE-498A116E39F9/appyinxiangcom/27330777/ENResource/p106",alt:"d833aae0d8fcfe4de4aee85bc14f6637.png"})),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Unbuffered channel \u662f block\u7684"),(0,o.kt)("li",{parentName:"ul"},"\u53ef\u4ee5\u914d\u7f6erange\u4f7f\u7528"),(0,o.kt)("li",{parentName:"ul"},"Buffered channel\u5728buffer\u6ee1\u4e4b\u524d\u662funblock\u7684"),(0,o.kt)("li",{parentName:"ul"},"\u6709receiver\u7684\u573a\u666f \u65b0\u53d1\u9001\u7ed9channel\u7684\u503c\u76f4\u63a5\u53d1\u9001\u7ed9receiver \u4e0d\u5b58\u5728slot")),(0,o.kt)("h4",{id:"channel\u7684scope\u8981\u6e05\u6670"},"channel\u7684scope\u8981\u6e05\u6670"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"channel owner\u7684\u804c\u8d23"),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},"Instantiate the channel."),(0,o.kt)("li",{parentName:"ul"},"Perform writes, or pass ownership to another goroutine."),(0,o.kt)("li",{parentName:"ul"},"Close the channel."),(0,o.kt)("li",{parentName:"ul"},"Ecapsulate the previous three things in this list and expose them via a reader channel."))),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"\u660e\u786e\u804c\u8d23\u4e4b\u540e\u53ef\u4ee5\u89c4\u907f\u7684\u98ce\u9669"),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},"Because we\u2019re the one initializing the channel, we remove the risk of deadlocking by writing to a nil channel."),(0,o.kt)("li",{parentName:"ul"},"Because we\u2019re the one initializing the channel, we remove the risk of panicing by closing a nil channel."),(0,o.kt)("li",{parentName:"ul"},"Because we\u2019re the one who decides when the channel gets closed, we remove the risk of panicing by writing to a closed channel."),(0,o.kt)("li",{parentName:"ul"},"Because we\u2019re the one who decides when the channel gets closed, we remove the risk of panicing by closing a channel more than once."),(0,o.kt)("li",{parentName:"ul"},"We wield the type checker at compile time to prevent improper writes to our channel"))),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Consumer\u548cchannel owner\u7684\u5173\u7cfb"),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},"Knowing when a channel is closed."),(0,o.kt)("li",{parentName:"ul"},"Responsibly handling blocking for any reason."))),(0,o.kt)("h3",{id:"the-select-statement"},"The select Statement"),(0,o.kt)("p",null,"The select statement is the glue that binds channels together; it\u2019s how we\u2019re able to compose channels together in a program to form larger abstractions"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"var c1, c2 <-chan interface{}\nvar c3 chan<- interface{}\nselect {\ncase <- c1:\n    // Do something\ncase <- c2:\n    // Do something\ncase c3<- struct{}{}:\n    // Do something\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"select\u6bcf\u4e2acase\u8fdb\u5165\u7684\u6982\u7387\u76f8\u7b49 \u548c\u987a\u5e8f\u65e0\u5173"),(0,o.kt)("li",{parentName:"ul"},"time.After\u4f7f\u7528select\u7684timeout")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'var c <-chan int\nselect {\ncase <-c: \ncase <-time.After(1 * time.Second):\n    fmt.Println("Timed out.")\n}\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u7a7aselect\u4f1a\u6c38\u8fdcblcok")),(0,o.kt)("h3",{id:"the-gomaxprocs-lever"},"The GOMAXPROCS Lever"),(0,o.kt)("p",null,'\u201creally this function controls the number of OS threads that will host so-called "work queues."'),(0,o.kt)("h2",{id:"chapter-4-concurrency-patterns-in-go"},"Chapter 4. Concurrency Patterns in Go"),(0,o.kt)("h3",{id:"confinement"},"Confinement"),(0,o.kt)("p",null,"Confinement is the simple yet powerful idea of ensuring information is only ever available from one concurrent process.\n\u5bf9\u4e8e\u5e76\u53d1\u7684process confinement\u53ea\u4f1a\u5bf9\u5176\u4e2d\u4e00\u4e2aavailable"),(0,o.kt)("h4",{id:"ad-hoc"},"ad hoc"),(0,o.kt)("p",null,"Ad hoc confinement is when you achieve confinement through a convention\u2014whether it be set by the languages community, the group you work within, or the codebase you work within"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"data := make([]int, 4)\n\nloopData := func(handleData chan<- int) {\n    defer close(handleData)\n    for i := range data {\n        handleData <- data[i]\n    }\n}\n\nhandleData := make(chan int)\ngo loopData(handleData)\n\nfor num := range handleData {\n    fmt.Println(num)\n}\n")),(0,o.kt)("h4",{id:"lexical"},"lexical"),(0,o.kt)("p",null,"Lexical confinement involves using lexical scope to expose only the correct data and concurrency primitives for multiple concurrent processes to use."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'chanOwner := func() <-chan int {\n    results := make(chan int, 5) \n    go func() {\n        defer close(results)\n        for i := 0; i <= 5; i++ {\n            results <- i\n        }\n    }()\n    return results\n}\n\nconsumer := func(results <-chan int) { \n    for result := range results {\n        fmt.Printf("Received: %d\\n", result)\n    }\n    fmt.Println("Done receiving!")\n}\n\nresults := chanOwner()        \nconsumer(results)\n')),(0,o.kt)("h3",{id:"the-for-select-loop"},"The for-select Loop"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"for { // Either loop infinitely or range over something\n    select {\n    // Do some work with channels\n    }\n}\n")),(0,o.kt)("h3",{id:"preventing-goroutine-leaks"},"Preventing Goroutine Leaks"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"\u4ec0\u4e48\u65f6\u5019\u7ed3\u675fgoroutine\u7684\u751f\u547d\u5468\u671f"),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},"When it has completed its work."),(0,o.kt)("li",{parentName:"ul"},"When it cannot continue its work due to an unrecoverable error."),(0,o.kt)("li",{parentName:"ul"},"When it\u2019s told to stop working."))),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"\u4e00\u822c\u6765\u8bf4 main goroutine\u6709\u6700\u8be6\u7ec6\u7684\u4e0a\u4e0b\u6587 \u6211\u4eec\u671f\u671b\u5728main goroutine\u901a\u77e5sub goroutine\u7ed3\u675f")),(0,o.kt)("p",null,"\u53ef\u4ee5\u901a\u8fc7done channel\u901a\u77e5goroutine\u7ed3\u675f"),(0,o.kt)("h3",{id:"the-or-channel"},"The or-channel"),(0,o.kt)("p",null,"At times you may find yourself wanting to combine one or more done channels into a single done channel that closes if any of its component channels close."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"var or func(channels ...<-chan interface{}) <-chan interface{}\nor = func(channels ...<-chan interface{}) <-chan interface{} { \n    switch len(channels) {\n    case 0: \n        return nil\n    case 1: \n        return channels[0]\n    }\n\n    orDone := make(chan interface{})\n    go func() { \n        defer close(orDone)\n\n        switch len(channels) {\n        case 2: \n            select {\n            case <-channels[0]:\n            case <-channels[1]:\n            }\n        default: \n            select {\n            case <-channels[0]:\n            case <-channels[1]:\n            case <-channels[2]:\n            case <-or(append(channels[3:], orDone)...): \n            }\n        }\n    }()\n    return orDone\n}\n")),(0,o.kt)("h4",{id:"error-handling"},"Error Handling"),(0,o.kt)("p",null,"\u628a\u9519\u8bef\u629b\u51fa \u4e0a\u4e0b\u6587\u6700\u5168\u7684goroutine\u63a5\u4f4f\u9519\u8bef\u4e4b\u540e\u5f00\u59cb\u5904\u7406"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'type Result struct { \n    Error error\n    Response *http.Response\n}\ncheckStatus := func(done <-chan interface{}, urls ...string) <-chan Result { \n    results := make(chan Result)\n    go func() {\n        defer close(results)\n\n        for _, url := range urls {\n            var result Result\n            resp, err := http.Get(url)\n            result = Result{Error: err, Response: resp} \n            select {\n            case <-done:\n                return\n            case results <- result: \n            }\n        }\n    }()\n    return results\n}\ndone := make(chan interface{})\ndefer close(done)\n\nurls := []string{"https://www.google.com", "https://badhost"}\nfor result := range checkStatus(done, urls...) {\n    if result.Error != nil { \n        fmt.Printf("error: %v", result.Error)\n        continue\n    }\n    fmt.Printf("Response: %v\\n", result.Response.Status)\n}\n')),(0,o.kt)("h3",{id:"pipelines"},"Pipelines"),(0,o.kt)("p",null,"By using a pipeline, you separate the concerns of each stage, which provides numerous benefits.\nYou can modify stages independent of one another, you can mix and match how stages are combined independent of modifying the stages, you can process each stage concurrent to upstream or downstream stages, and you can fan-out, or rate-limit portions of your pipeline."),(0,o.kt)("h4",{id:"stage"},"Stage"),(0,o.kt)("p",null,"A stage consumes and returns the same type.\nA stage must be reified2 by the language so that it may be passed around. Functions in Go are reified and fit this purpose nicely."),(0,o.kt)("h4",{id:"best-practices-for-constructing-pipelines"},"Best Practices for Constructing Pipelines"),(0,o.kt)("p",null,"Use chanel to fulfill ",(0,o.kt)("inlineCode",{parentName:"p"},"pipeline")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"generator := func(done <-chan interface{}, integers ...int) <-chan int {\n    intStream := make(chan int)\n    go func() {\n        defer close(intStream)\n        for _, i := range integers {\n            select {\n            case <-done:\n                return\n            case intStream <- i:\n            }\n        }\n    }()\n    return intStream\n}\n\nmultiply := func(\n  done <-chan interface{},\n  intStream <-chan int,\n  multiplier int,\n) <-chan int {\n    multipliedStream := make(chan int)\n    go func() {\n        defer close(multipliedStream)\n        for i := range intStream {\n            select {\n            case <-done:\n                return\n            case multipliedStream <- i*multiplier:\n            }\n        }\n    }()\n    return multipliedStream\n}\n\nadd := func(\n  done <-chan interface{},\n  intStream <-chan int,\n  additive int,\n) <-chan int {\n    addedStream := make(chan int)\n    go func() {\n        defer close(addedStream)\n        \u201c        for i := range intStream {\n            select {\n            case <-done:\n                return\n            case addedStream <- i+additive:\n            }\n        }\n    }()\n    return addedStream\n}\n\ndone := make(chan interface{})\ndefer close(done)\n\nintStream := generator(done, 1, 2, 3, 4)\npipeline := multiply(done, add(done, multiply(done, intStream, 2), 1), 2)\n\nfor v := range pipeline {\n    fmt.Println(v)\n}\n")),(0,o.kt)("h4",{id:"some-handy-generators"},"Some Handy Generators"),(0,o.kt)("p",null,"a generator for a pipeline is any function that converts a set of discrete values into a stream of values on a channel"),(0,o.kt)("h5",{id:"repeat"},"repeat"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"repeat := func(\n    done <-chan interface{},\n    values ...interface{},\n) <-chan interface{} {\n    valueStream := make(chan interface{})\n    go func() {\n        defer close(valueStream)\n        for {\n            for _, v := range values {\n                select {\n                case <-done:\n                    return\n                case valueStream <- v:\n                }\n            }\n        }\n    }()\n    return valueStream\n}\n")),(0,o.kt)("h5",{id:"take"},"take"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"take := func(\n    done <-chan interface{},\n    valueStream <-chan interface{},\n    num int,\n) <-chan interface{} {\n    takeStream := make(chan interface{})\n    go func() {\n        defer close(takeStream)\n        for i := 0; i < num; i++ {\n            select {\n            case <-done:\n                return\n            case takeStream <- <- valueStream:\n            }\n        }\n    }()\n    return takeStream\n}\n")),(0,o.kt)("h5",{id:"repeatfn"},"repeatFn"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"repeatFn := func(\n    done <-chan interface{},\n    fn func() interface{},\n) <-chan interface{} {\n    valueStream := make(chan interface{})\n    go func() {\n        defer close(valueStream)\n        for {\n            select {\n            case <-done:\n                return\n            case valueStream <- fn():\n            }\n        }\n    }()\n    return valueStream\n}\n")),(0,o.kt)("h3",{id:"fan-out-fan-in"},"Fan-Out, Fan-In"),(0,o.kt)("p",null,"Fan-out is a term to describe the process of starting multiple goroutines to handle input from the pipeline, and fan-in is a term to describe the process of combining multiple results into one channel."),(0,o.kt)("p",null,"fan-out: \u7528\u591a\u4e2agoroutine\u8bfb\u53d6\u6570\u636e\nfan-in: \u5c06\u591a\u4e2agoroutine\u5408\u5e76\u8f93\u51fa\u5230\u4e00\u4e2achannel"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Prerequisite"),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},"It doesn\u2019t rely on values that the stage had calculated before"),(0,o.kt)("li",{parentName:"ul"},"It takes a long time to run"))),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"fan-out\u4e0d\u4fdd\u8bc1\u6267\u884c\u987a\u5e8f")),(0,o.kt)("h3",{id:"the-or-done-channel"},"The or-done-channel"),(0,o.kt)("p",null,"done\u6216\u8005work"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"\u201corDone := func(done, c <-chan interface{}) <-chan interface{} {\n    valStream := make(chan interface{})\n    go func() {\n        defer close(valStream)\n        for {\n            select {\n            case <-done:\n                return\n            case v, ok := <-c:\n                if ok == false {\n                    return\n                }\n                select {\n                case valStream <- v:\n                case <-done:\n                }\n            }\n        }\n    }()\n    return valStream\n}\n")),(0,o.kt)("h3",{id:"the-tee-channel"},"The tee-channel"),(0,o.kt)("p",null,"\u540c\u6837\u7684\u503c\u53d1\u4e24\u904d"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"tee := func(\n    done <-chan interface{},\n    in <-chan interface{},\n) (_, _ <-chan interface{}) { <-chan interface{}) {\n    out1 := make(chan interface{})\n    out2 := make(chan interface{})\n    go func() {\n        defer close(out1)\n        defer close(out2)\n        for val := range orDone(done, in) {\n            var out1, out2 = out1, out2 \n            for i := 0; i < 2; i++ { \n                select {\n                case <-done:\n                case out1<-val:\n                    out1 = nil \n                case out2<-val:\n                    out2 = nil \n                }\n            }\n        }\n    }()\n    return out1, out2\n}\n")),(0,o.kt)("h3",{id:"the-bridge-channel"},"The bridge-channel"),(0,o.kt)("p",null,"\u628a\u591a\u4e2achannel combine\u8d77\u6765"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"\u201cbridge := func(\n    done <-chan interface{},\n    chanStream <-chan <-chan interface{},\n) <-chan interface{} {\n    valStream := make(chan interface{}) \n    go func() {\n        defer close(valStream)\n        for { \n            var stream <-chan interface{}\n            select {\n            case maybeStream, ok := <-chanStream:\n                if ok == false {\n                    return\n                }\n                stream = maybeStream\n            case <-done:\n                return\n            }\n            for val := range orDone(done, stream) { \n                select {\n                case valStream <- val:\n                case <-done:\n                }\n            }\n        }\n    }()\n    return valStream\n}\n")),(0,o.kt)("h3",{id:"queuing"},"queuing"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"queuing \u4e0d\u80fd\u63d0\u9ad8pipeline\u7684\u6574\u4f53\u6027\u80fd \u4f46\u662f\u80fd\u63d0\u9ad8\u67d0\u4e2astage\u7684\u6027\u80fd"),(0,o.kt)("li",{parentName:"ul"},"queuing\u80fd\u907f\u514d\u6076\u6027\u5faa\u73af"),(0,o.kt)("li",{parentName:"ul"},"\u5e94\u8be5\u653e\u5728pipeline\u7684\u5165\u53e3 \u6216\u8005\u6279\u5904\u7406stage\u7684\u524d\u9762"),(0,o.kt)("li",{parentName:"ul"},"panic\u7684\u65f6\u5019\u53ef\u80fd\u4f1a\u4e22\u6570\u636e")),(0,o.kt)("h3",{id:"the-context-package"},"The context Package"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"cancellation"),(0,o.kt)("li",{parentName:"ul"},"timeout"),(0,o.kt)("li",{parentName:"ul"},"WithValue")),(0,o.kt)("h2",{id:"chapter-5-concurrency-at-scale"},"Chapter 5. Concurrency at Scale"),(0,o.kt)("h3",{id:"error-propagation"},"Error Propagation"),(0,o.kt)("p",null,"concurrency\u7684\u7a0b\u5e8f\u5e94\u8be5\u66f4\u52a0\u91cd\u89c6\u9519\u8bef\u7684\u5904\u7406"),(0,o.kt)("p",null,"\u9519\u8bef\u53d1\u751f\u65f6\u9700\u8981\u77e5\u9053\u8fd9\u4e9b\u4fe1\u606f"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"What happened"),(0,o.kt)("li",{parentName:"ul"},"When and where occurred"),(0,o.kt)("li",{parentName:"ul"},"A friendly user-facing message"),(0,o.kt)("li",{parentName:"ul"},"How the user can get more information")),(0,o.kt)("p",null,"\u4e3a\u4ec0\u4e48\u8981\u91cd\u89c6\u9519\u8bef\u5904\u7406"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u5904\u7406\u8fc7\u7684\u9519\u8bef\u6211\u4eec\u4f1a\u5f88\u6709\u81ea\u4fe1"),(0,o.kt)("li",{parentName:"ul"},"\u5bf9\u4e8e\u7528\u6237 \u5e94\u8be5\u59cb\u7ec8\u7ed9\u5c01\u88c5\u540e\u7684\u9519\u8bef")),(0,o.kt)("h3",{id:"timeouts-and-cancellation"},"Timeouts and Cancellation"),(0,o.kt)("p",null,"timeout\u573a\u666f"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"System saturation",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"\u7cfb\u7edf\u9971\u548c"))),(0,o.kt)("li",{parentName:"ul"},"Stale data"),(0,o.kt)("li",{parentName:"ul"},"Attempting to prevent deadlocks")),(0,o.kt)("p",null,"cancel\u7684\u573a\u666f"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"timeout"),(0,o.kt)("li",{parentName:"ul"},"User intervention"),(0,o.kt)("li",{parentName:"ul"},"Parent cancellation"),(0,o.kt)("li",{parentName:"ul"},"Replicated requests")),(0,o.kt)("h3",{id:"heartbeats"},"Heartbeats"),(0,o.kt)("p",null,"Heartbeats are a way for concurrent processes to signal life to outside parties"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"doWork := func(\n    done <-chan interface{},\n    pulseInterval time.Duration,\n) (<-chan interface{}, <-chan time.Time) {\n    heartbeat := make(chan interface{}) \n    results := make(chan time.Time)\n    go func() {\n        defer close(heartbeat)\n        defer close(results)\n\n        pulse := time.Tick(pulseInterval) \n        workGen := time.Tick(2*pulseInterval) \n\n        sendPulse := func() {\n            select {\n            case heartbeat <-struct{}{}:\n            default: \n            }\n        }\n        sendResult := func(r time.Time) {\n            for {\n                select {\n                case <-done:\n                    return\n                case <-pulse: \n                    sendPulse()\n                case results <- r:\n                    return\n                }\n            }\n        }\n\n        for {\n            select {\n            case <-done:\n                return\n            case <-pulse: \n                sendPulse()\n            case r := <-workGen:\n                sendResult(r)\n            }\n        }\n    }()\n    return heartbeat, results\n}\n")),(0,o.kt)("h3",{id:"replicated-requests"},"Replicated Requests"),(0,o.kt)("h3",{id:"rate-limiting"},"Rate Limiting"),(0,o.kt)("p",null,"\u907f\u514dddos\u5171\u8ba1\u6216\u8005\u96ea\u5d29"),(0,o.kt)("p",null,"access toekn"),(0,o.kt)("h3",{id:"healing-unhealthy-goroutines"},"Healing Unhealthy Goroutines"),(0,o.kt)("h2",{id:"chapter-6-goroutines-and-the-go-runtime"},"Chapter 6. Goroutines and the Go Runtime"),(0,o.kt)("h3",{id:"work-steal"},"work steal"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"At a fork point, add tasks to the tail of the deque associated with the thread."),(0,o.kt)("li",{parentName:"ol"},"If the thread is idle, steal work from the head of deque associated with some other random thread."),(0,o.kt)("li",{parentName:"ol"},"At a join point that cannot be realized yet (i.e., the goroutine it is synchronized with has not completed yet), pop work off the tail of the thread\u2019s own deque."),(0,o.kt)("li",{parentName:"ol"},"If the thread\u2019s deque is empty, either:"),(0,o.kt)("li",{parentName:"ol"},"Stall at a join."),(0,o.kt)("li",{parentName:"ol"},"Steal work from the head of a random thread\u2019s associated deque.")))}u.isMDXComponent=!0}}]);